    def fmt = \self: TypeHint, writer: \Seq[Byte] -> Nil, namespace: Namespace ->
      self.toGenName(writer, namespace)

    def toGenName = \self: TypeHint, writer: \Seq[Byte] -> Nil, namespace: Namespace ->
      match self
        case ScalarTh(params, name, pkg) do
          val foundType = namespace.types.find(\t -> t.name == name).get
          match foundType
            case scalar: ScalarDecl do scalar.name
            case StructDecl(_, sparams, sname, _) do
              '%s[%seq]'.ffmt(buff, sname, params)
            case UnionDecl(uparams, uname, _) do
              '%s[%seq]'.ffmt(buff, uname, params) .
        case StructTh(fields) do
          '(%seq)'.ffmt(buff, fields)
        case UnionTh(variants) do
          '%seq(' | ')'.ffmt(buff, variants)
        case FnTh(args, ret) do
          '\%seq -> %seq)'.fmtBuff(buff, args, ret) ..

    def usage =
      val th = getSomeTypeHint(x, y, z)
      val buff = StringBuff(length = 128)
      th.toGenName(buff.writer, namespace)
      buff.str .
# abra.io
    def readLn = readerUntil: \Long, Byte, \Seq[Byte] -> Nil = stdin.reader ->
      val buff = StringBuff()
      while true do
        reader with 1, \bytes ->
          buff.add(bytes(0))
          if bytes(0) == string.nl do break ....
reader: \Long, \Seq[Byte] -> Nil -> Nil
 '%tvec1=%v(.x, .y) vec2=%v(.x, .y) %nl'.fmt(Vec2(1, 1), v2)
 proc doWork(inFilenames: seq[string] = nil,
             outFilename: string = nil,
             ignoreCase: bool = false) {.raises: [IOError].} =
   # Open files
   var
     infiles: seq[File] = @[stdin]
     outfile: File = stdout
   if inFilenames != nil and inFilenames.len > 0:
     infiles = inFilenames.mapIt(File, (proc (filename: string): File =
     if not open(result, filename):
        raise newException(IOError, "Failed to open file: " & filename)
     )(it))
   if outFilename != nil and outFilename.len > 0 and not open(outfile, outFilename, fmWrite):
     raise newException(IOError, "Failed to open file: " & outFilename)

   # Parse words
   var counts = initCountTable[string]()
   for infile in infiles:
     for line in infile.lines:
       let input = if ignoreCase: line.tolower() else: line
       let words = try: input.findAll(peg"\w+") except: @[]
       for word in words:
         counts.inc(word)

   # Write counts
   var words = toSeq(counts.keys)
   sort(words, cmp)
   for word in words:
     outfile.writeln(counts[word], '\t', word)

def doWork = \inFilenames: Seq[String] = seq.empty,
              outFilename: String | Nil = Nil,
              ignoreCase: Bool = false ->
  val inFiles =
    if inFilenames.isEmpty do seq.of(io.stdin)
    else inFilenames.map(\name -> io.open(name)) .

  val outFile =
    if outFilename == Nil do io.stdout
    else io.open(outFilename) .

  val counts = hashMap.empty[String, Int]

  inFiles.forEach with \file ->
    file.lines.forEach with \line ->
      val input = if ignoreCase do line.toLower else line .
        input.split.forEach with '\w+', \word ->
          val count = match counts(word) case n: Int do n else 0
          counts(word) = count + 1 ...

  val sorted = count.keys.sort(\k1, k2 -> counts(k1) > counts(k2))
  sorted.forEach with \word ->
    io.printLn(word, outFile) ..



def doWork = \inFilenames: Seq[String] = seq.empty,
              outFilename: String | Nil = Nil,
              ignoreCase: Bool = false ->
  val inFiles =
    if inFilenames.empty is true do seq.of(io.stdin)
    else inFilenames.map(\name -> io.open(name)) .

  val outFile =
    if outFilename is String do io.open(outFilename)
    else io.stdout .

  val counts = hashMap.empty[String, Int]

  inFiles.forEach with \file ->
    file.lines.forEach with \line ->
      val input = if ignoreCase is true do line.toLower else line .
        input.split.forEach with '\w+', \word ->
          val count = if counts(word) is n: Int do n else 0 .
          counts(word) = count + 1 ...

  val sorted = count.keys.sort(\k1, k2 -> counts(k1) > counts(k2))
  sorted.forEach with \word ->
    io.printLn(word, outFile) ..
type Virtual = (name: String)
type Field = (name: String, ref: TypeRef)

type LowType = (name: String, llValue: String)
type Struct = (specs: Seq[Virtual], name: String, fields: Seq[Field])
type Union = (specs: Seq[Virtual], name: String, variants: Seq[TypeRef])
type Type = LowType | Struct | Union

type SRef = (specs: Seq[TypeRef], pkg: Option[String], name: String) # Scalar type reference
type FRef = (args: Seq[TypeRef], ret: TypeRef) # Functional type reference
type TypeRef =  SRef | FRef

def lnspec = \name: String -> SRef(Seq(), None, name)

type Const = (v: String)
type Id = (v: String, props: Seq[String])
type Lit = Const | Id

type Store = (i1: Id, i2: Lit)

type Cond = (i1: Id, l: Seq[Stat], r: Seq[Stat])
type Or = (i: Id, l: Seq[Stat], r: Seq[Stat])
type And = (i: Id, l: Seq[Stat], r: Seq[Stat])
type While = (i: Id, head: Seq[Stat], body: Seq[Stat])
type Ret = ()

type Cons = (ref: TypeRef, ret: Id, args: Seq[Lit])
type Call = (specs: TypeRef, i: Id, args: Seq[Lit])
type ModCall = (specs: TypeRef, pkg: String, name: String, args: Seq[Lit])

type LLCode(value: String)
type AbraCode(stats: Seq[Stat])
type Code = LLCode | AbraCode
type Closure = (name: String, args: Seq[Field], ret: Option[TypeRef], code: Code)

type Stat = Store | Cond | Or | And | While | Ret | Cons | Call | ModCall | Closure

type Module = (typeMap: Map[String, Type], closureMap: Map[String, Closure])
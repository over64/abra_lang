
package m3.grammar

import grammar.EvaLexer.Lex
import m3.grammar.ParseNS.{PResult, WithCtx}

trait LiteralCodeGen extends WithCtx {
  @inline def l_ident = ctx.tryFetch(Lex.IDENT, { t => Right(t) })
	@inline def l_comment = ctx.tryFetch(Lex.COMMENT, { _ => Right(()) })
	@inline def l_dot = ctx.tryFetch(Lex.DOT, { _ => Right(()) })
	@inline def l_comma = ctx.tryFetch(Lex.COMMA, { _ => Right(()) })
	@inline def l_con = ctx.tryFetch(Lex.CON, { _ => Right(()) })
	@inline def l_v_line = ctx.tryFetch(Lex.V_LINE, { _ => Right(()) })
	@inline def l_eq = ctx.tryFetch(Lex.EQ, { _ => Right(()) })
	@inline def l_r_arrow = ctx.tryFetch(Lex.R_ARROW, { _ => Right(()) })
	@inline def l_l_paren = ctx.tryFetch(Lex.L_PAREN, { _ => Right(()) })
	@inline def l_r_paren = ctx.tryFetch(Lex.R_PAREN, { _ => Right(()) })
	@inline def l_l_bracket = ctx.tryFetch(Lex.L_BRACKET, { _ => Right(()) })
	@inline def l_r_bracket = ctx.tryFetch(Lex.R_BRACKET, { _ => Right(()) })
	@inline def l_logic_not = ctx.tryFetch(Lex.LOGIC_NOT, { _ => Right(()) })
	@inline def l_logic_or = ctx.tryFetch(Lex.LOGIC_OR, { _ => Right(()) })
	@inline def l_logic_and = ctx.tryFetch(Lex.LOGIC_AND, { _ => Right(()) })
	@inline def l_cmp_more = ctx.tryFetch(Lex.CMP_MORE, { _ => Right(()) })
	@inline def l_cmp_less = ctx.tryFetch(Lex.CMP_LESS, { _ => Right(()) })
	@inline def l_cmp_more_eq = ctx.tryFetch(Lex.CMP_MORE_EQ, { _ => Right(()) })
	@inline def l_cmp_less_eq = ctx.tryFetch(Lex.CMP_LESS_EQ, { _ => Right(()) })
	@inline def l_cmp_eqeq = ctx.tryFetch(Lex.CMP_EQEQ, { _ => Right(()) })
	@inline def l_cmp_noteq = ctx.tryFetch(Lex.CMP_NOTEQ, { _ => Right(()) })
	@inline def l_bin_minus = ctx.tryFetch(Lex.BIN_MINUS, { _ => Right(()) })
	@inline def l_bin_plus = ctx.tryFetch(Lex.BIN_PLUS, { _ => Right(()) })
	@inline def l_bin_mul = ctx.tryFetch(Lex.BIN_MUL, { _ => Right(()) })
	@inline def l_bin_div = ctx.tryFetch(Lex.BIN_DIV, { _ => Right(()) })
	@inline def l_import = ctx.tryFetch(Lex.IMPORT, { _ => Right(()) })
	@inline def l_type = ctx.tryFetch(Lex.TYPE, { _ => Right(()) })
	@inline def l_def = ctx.tryFetch(Lex.DEF, { _ => Right(()) })
	@inline def l_with = ctx.tryFetch(Lex.WITH, { _ => Right(()) })
	@inline def l_if = ctx.tryFetch(Lex.IF, { _ => Right(()) })
	@inline def l_do = ctx.tryFetch(Lex.DO, { _ => Right(()) })
	@inline def l_else = ctx.tryFetch(Lex.ELSE, { _ => Right(()) })
	@inline def l_is = ctx.tryFetch(Lex.IS, { _ => Right(()) })
	@inline def l_unless = ctx.tryFetch(Lex.UNLESS, { _ => Right(()) })
	@inline def l_while = ctx.tryFetch(Lex.WHILE, { _ => Right(()) })
	@inline def l_break = ctx.tryFetch(Lex.BREAK, { _ => Right(()) })
	@inline def l_continue = ctx.tryFetch(Lex.CONTINUE, { _ => Right(()) })
	@inline def l_return = ctx.tryFetch(Lex.RETURN, { _ => Right(()) })
	@inline def l_id = ctx.tryFetch(Lex.ID, { t => Right(t) })
	@inline def l_type_id = ctx.tryFetch(Lex.TYPE_ID, { t => Right(t) })
	@inline def l_lit_none = ctx.tryFetch(Lex.LIT_NONE, { _ => Right(()) })
	@inline def l_lit_bool = ctx.tryFetch(Lex.LIT_BOOL, { _ => Right(()) })
	@inline def l_lit_int = ctx.tryFetch(Lex.LIT_INT, { _ => Right(()) })
	@inline def l_lit_float = ctx.tryFetch(Lex.LIT_FLOAT, { _ => Right(()) })
	@inline def l_lit_string = ctx.tryFetch(Lex.LIT_STRING, { _ => Right(()) })
	@inline def l_native = ctx.tryFetch(Lex.NATIVE, { _ => Right(()) })
}
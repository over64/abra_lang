type Vec3 = (x: Float, y: Float, z: Float)

type Vec4 = (x: Float, y: Float, z: Float, w: Float)

type Mat3 = (
    x1: Float, y1: Float, z1: Float,
    x2: Float, y2: Float, z2: Float,
    x3: Float, y3: Float, z3: Float
)

type Mat4 = (
    x1: Float, y1: Float, z1: Float, w1: Float,
    x2: Float, y2: Float, z2: Float, w2: Float,
    x3: Float, y3: Float, z3: Float, w3: Float,
    x4: Float, y4: Float, z4: Float, w4: Float
)

def identity4: () -> Mat4 = llvm {
    call void @kmMat4Identity(%struct.lib.kazmath.Mat4* %ret)
    ret void
}

def rotateZ: (self: Mat4, radians: Float) -> Mat4 = llvm {
    %1 = load %struct.lib.kazmath.Mat4, %struct.lib.kazmath.Mat4* %self
    store %struct.lib.kazmath.Mat4 %1, %struct.lib.kazmath.Mat4* %ret
    call void @kmMat4RotationZ(%struct.lib.kazmath.Mat4* %ret, float %radians)
    ret void
}

def rotateY: (self: Mat4, radians: Float) -> Mat4 = llvm {
    %1 = load %struct.lib.kazmath.Mat4, %struct.lib.kazmath.Mat4* %self
    store %struct.lib.kazmath.Mat4 %1, %struct.lib.kazmath.Mat4* %ret
    call void @kmMat4RotationY(%struct.lib.kazmath.Mat4* %ret, float %radians)
    ret void
}

def perspective: (fov: Float, aspectRatio: Float, zNear: Float, zFar: Float) -> Mat4 = llvm {
    %mat = bitcast %struct.lib.kazmath.Mat4* %ret to float*
    call float* @kmMat4PerspectiveProjection(float* %mat, float %fov, float %aspectRatio, float %zNear, float %zFar)
    ret void
}

def lookAt: (eye: Vec3, center: Vec3, up: Vec3) -> Mat4 = llvm {
    call void @kmMat4LookAt(%struct.lib.kazmath.Mat4* %ret, %struct.lib.kazmath.Vec3* %eye, %struct.lib.kazmath.Vec3* %center, %struct.lib.kazmath.Vec3* %up)
    ret void
}

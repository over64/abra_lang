# 1. Если функция бросает исключение, то при вызове к имени добавляется ?
# 2. Сигнатура функции(в коде программы) не содержит типов бросаемых исключений,
#    но они будут отображаться в IDE
# Комментарии только на новой строке
# 3. rescue - of блоки для отлова исключений
# 4. Исключения кидаются через raise
# 5. Кинуть можно только те объекты, которые имеют поле trace: STrace и именуются *Err
# 6. При raise из resque-of блока нужно прицепить пойманный exception в поле cause

type IOErr = (errno: Int, trace: STrace)
def toString = io.perror(errno)

def stdin = llvm {
}: In
def readLine? = { stream: In = stdin ->

} # Nil raises IOErr

import abra@0.4.3/io with IOErr
import kibana@0.0.1/kibana with KibanaErr

type MainErr = (cause: IOErr, trace: STrace)

def main = {
    rescue
        val l1 = io.readLine?() # String
        val l2 = io.readLine?() # String
        io.println('Two lines concat: ${ l1 + l2 }') # Nil
    of e: IOErr -> {
        kibana.event('readline_failed')
            .param('nLines', 2)
            .param('trace', e.toString).send?() # Nil
        raise MainErr(e)
    }
} # Nil raises MainErr | KibanaErr

# vs F#

let uspGetManagerEmployees =
    async {
        let! res = ctx.Procedures.UspGetManagerEmployees.InvokeAsync 2
        let mapped = res.ResultSet |> Array.map(fun i -> i.ColumnValues |> Map.ofSeq)
        mapped |> Array.iter(fun i ->
            printfn "Name: %O, Level: %O" i.["FirstName"] i.["RecursionLevel"]
        )
    } |> Async.StartAsTask

val uspGetManagerEmployees =
    async?({
        val res = ctx.procedures.uspGetManagerEmployees.invoke?(2)
        val mapped = res.resultSet.map(\i -> i.columnValues.toSeq)
        mapped.forEach(\i -> println('Name: ${ i('FirstName') }, Level: ${ i('RecursionLevel') }')
    })



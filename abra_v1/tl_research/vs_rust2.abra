fn create_player(player: &Player, tattva: Alb<Tattva>, storage: Al<Storage<Player, PlayerParams>>, idf: Al<IdFactory>) -> Result<Player, PlayerInitializeError> {
	let universe = get_universe(player.uid)?; // <- get_universe возвращает Result<Universe, PlayerInitializeError>. Если она вернула error, create_player тоже его возвращает тут же. Похоже на проброс исключения в Java.
	let mut player = player.clone();
	player.id = idf.write().unwrap().player();
	let params = PlayerParams {
		universe: universe.name.clone(),
		lookup: PlayerParamsLookup::Id(player.id),
	};
	storage.write().unwrap().save(&player, ¶ms).map_err(|e| {
		error!("[{}] Error saving player {} '{}': {}", SCENE_NAME, player.id, player.name, e);
		PlayerInitializeError::CannotSave
	})?; // save возвращает Result<(), StorageError>. StorageError нельзя вернуть вместо PlayerInitializeError, поэтому мы его преобразовываем с помощью map_err, а заодно и логгируем. Можно враппер написать, но обычно незачем, если все логгируется.
	Ok(player)
}

def createPlayer = { player: *Player, tattva: Alb[Tattva], storage: Al[Storage[Player, PlayerParams]], idf: Al[IdFactory] ->
	val universe = getUniverse(player.uid)? # <- get_universe возвращает Result<Universe, PlayerInitializeError>. Если она вернула error, create_player тоже его возвращает тут же. Похоже на проброс исключения в Java.
	player.id = idf.write()?.player()

	val params = PlayerParams(
	    universe = universe.name.clone(),
		lookup = playerParamsLookup.Id(player.id)
	)

	storage.write()?.save(player).map_err({ e ->
		error!("[{}] Error saving player {} '{}': {}", SCENE_NAME, player.id, player.name, e);
		PlayerInitializeError::CannotSave
	})? # save возвращает Result<(), StorageError>. StorageError нельзя вернуть вместо PlayerInitializeError, поэтому мы его преобразовываем с помощью map_err, а заодно и логгируем. Можно враппер написать, но обычно незачем, если все логгируется.

	player
}: Player | PlayerInitializeError


pub fn parse(&mut self, message: &str) -> Result<(), &'static str> {
    for (k, v) in parse_table(&message) {
        match k {
            "frame" => self.frame = Rc::new(Frame::parse_from(v)?),

            "deaths" => self.deaths = v[1 .. v.len()-1] // strip quotes
                .split(',')
                .filter(|e| e.len() > 0) // a,,b
                .map(|x| x.parse().map_err(|_| "parse error"))
                .collect::<Result<_,_>>()?,

            // TODO
            _ => unimplemented!()
        }

    }

    Ok(())
}

def parse = { self: *ServerState, message: String ->
    parseTable.takeWhile[ErrStr]({ k, v ->
        match k
            of 'frame' -> self.frame = frames.parseFrom(v)?
            of 'deaths' -> self.deaths = v.strip('"')
                .split(',')
                .filter(\e -> e.length > 0)
                .map({ x -> x.parse.otherwise(\e -> 'parse error') })
            else None
    })?
}: None | ErrStr


pub fn matches(&self, name: &str, cfg: Option<&[Cfg]>) -> bool {
    match *self {
        Platform::Name(ref p) => p == name,
        Platform::Cfg(ref p) => {
            match cfg {
                Some(cfg) => p.matches(cfg),
                None => false,
            }
        }
    }
}

def matches = { self: *Platform, name: String, cfg: Cfg | None ->
    match *self
        of Name(p) -> p == name
        of Cfg(p) -> match cfg
            of x: Cfg -> p.matches(x)
            of None -> false
}: Boolean


impl FromStr for Platform {
    type Err = Box<CargoError>;

    fn from_str(s: &str) -> CargoResult<Platform> {
        if s.starts_with("cfg(") && s.ends_with(")") {
            let s = &s[4..s.len()-1];
            s.parse().map(Platform::Cfg).chain_error(|| {
                human(format!("failed to parse `{}` as a cfg expression", s))
            })
        } else {
            Ok(Platform::Name(s.to_string()))
        }
    }
}

def fromStr = { self: Platform, s: String
    if s.startsWith('cfg') && s.endsWith(')') then
        s.stripLeft('cfg').stripRight(')').toString.parse[Cfg]?
    else Name(s)
}: Platform | CargoError


# LANG XXX

pub fn status<T, U>(&mut self, status: T, message: U) -> CargoResult<()>
    where T: fmt::Display, U: fmt::Display
{
    match self.verbosity {
        Quiet => Ok(()),
        _ => self.err().say_status(status, message, GREEN, true)
    }
}

# VS

# LANG YYY

def status = \self: MultiShell,
              doStatus: (Stdout) -> None,
              doMessage: (Stdout) -> None ->
    match self.verbosity
        of Quiet -> None
        else self.err.sayStatus(statusOut, messageOut, color = GREEN, show = true)

# END

status(shell,
       doStatus  = \out -> out.print(Status.Wtf),
       doMessage = \out -> out.print('Oh my god'))


pub fn from_write(out: Box<Write + Send>, err: Box<Write + Send>) -> MultiShell {
    let config = ShellConfig { color_config: ColorConfig::Never, tty: false };
    let out = Shell { terminal: NoColor(out), config: config.clone() };
    let err = Shell { terminal: NoColor(err), config: config };
    MultiShell {
        out: out,
        err: err,
        verbosity: Verbosity::Quiet,
    }
}

def fromOut = { out: (Seq[Byte]) -> None, err: (Seq[Byte]) -> None ->
    val config = ShellConfig(ColorConfig.Never, tty = false)

    MultiShell(
        out = Shell(terminal = NoColor(out), config),
        err = Shell(terminal = NoColor(err), config),
        Verbosity.Quiet
    )
}: MultiShell


{
    let mut checksums = HashMap::new();
    let prefix = "checksum ";
    let mut to_remove = Vec::new();
    for (k, v) in metadata.iter().filter(|p| p.0.starts_with(prefix)) {
        to_remove.push(k.to_string());
        let k = &k[prefix.len()..];
        let enc_id: EncodablePackageId = k.parse().chain_error(|| {
            internal("invalid encoding of checksum in lockfile")
        })?;
        let id = match lookup_id(&enc_id) {
            Ok(Some(id)) => id,
            _ => continue,
        };

        let v = if v == "<none>" {
            None
        } else {
            Some(v.to_string())
        };
        checksums.insert(id, v);
    }

    for k in to_remove {
        metadata.remove(&k);
    }
}

{
    val checksums = hashMap.empty[K, V]
    val prefix = 'checksum'

    metadata.filter(\p -> p(0).startsWith(prefix)).takeWhile[ChecksumErr]({ k, v ->
        metadata.remove(k)

        val k = k.stripLeft(prefix)
        val encId = match k.parse[EncodablePackageId]
            of ok: String -> ok
            else return ChecksumErr("invalid encoding of checksum in lockfile")

        val id = match lookupId(encId)
            of id: Long -> id
            else return

        val v = if v == '<none>' then None else v
        checksums.put(id, v)
    })
}

    val checksums = hashMap.empty[K, V]
    val prefix = 'checksum'

    metadata.filter| p ->
        p(0).startsWith(prefix).takeWhile[ChecksumErr]| k, v ->
            metadata.remove(k)

            val k = k.stripLeft(prefix)
            val encId = match k.parse[EncodablePackageId]
                of ok: String -> ok
                else return ChecksumErr("invalid encoding of checksum in lockfile")

            val id = match lookupId(encId)
                of id: Long -> id
                else return

            val v = if v == '<none>' then None else v
            checksums.put(id, v)

fn build(pkg: &Package,
         config: &Config,
         ret: &mut HashMap<String, SourceId>,
         visited: &mut HashSet<SourceId>) {
    let replace = pkg.manifest().replace();
    let deps = pkg.dependencies()
                  .iter()
                  .chain(replace.iter().map(|p| &p.1))
                  .map(|d| d.source_id())
                  .filter(|id| !visited.contains(id) && id.is_path())
                  .filter_map(|id| id.url().to_file_path().ok())
                  .map(|path| path.join("Cargo.toml"))
                  .filter_map(|path| Package::for_path(&path, config).ok())
                  .collect::<Vec<_>>();
    for pkg in deps {
        ret.insert(pkg.name().to_string(),
                   pkg.package_id().source_id().clone());
        visited.insert(pkg.package_id().source_id().clone());
        build(&pkg, config, ret, visited);
    }
}

def build = { pkg: Package, config: Config, hm: *HashMap[String, SourceId], hs: *HashSet[SourceId] ->
    val deps = pkg.dependencies
        .map(\d -> d.sourceId)
        .filter(\id -> !visited.contains(id) && id.isPath)
        .filterMap(\id -> id.url.toFilePath)
        .map(\path -> path.join('Cargo.toml'))
        .filterMap(\path -> package.forPath(path, config))

    deps.forEach({ pkg ->
        hm.put(pkg.name, pkg.id.sourceId)
        hs.put(pkg.id.sourceId)
        build(pkg, config, hm, hs)
    })
}: None

def build = pkg: Package, config: Config, &hm: HashMap[String, SourceId], &hs: HashSet[SourceId] ->
    val deps = pkg.dependencies
        .map(d -> d.sourceId)
        .filter(id -> !visited.contains(id) && id.isPath)
        .filterMap(id -> id.url.toFilePath)
        .map(path -> path.join('Cargo.toml'))
        .filterMap(path -> package.forPath(path, config))

    deps.forEach| pkg ->
        hm.put(pkg.name, pkg.id.sourceId)
        hs.put(pkg.id.sourceId)
        build(pkg, config, hm, hs)
    : Unit
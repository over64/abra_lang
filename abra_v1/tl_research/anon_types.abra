def div = \a: Int, b: Int -> (d = a / b, rem = a mod b)
def div = { a: Int, b: Int ->
    (d = a / b, rem = a mod b)
}: (d: Int, rem: Int)

val (d, rem) = 3 div 2 # (1, 1) expected
match 3 div 2 of (d, rem) ->

val x: Int | Nil = bar(1, 2)
val x: Int | None = bar(1, 2)
val x: Int | Unit = bar(1, 2)


type Ast = Add = (l: Ast, r: Ast)
         | Sub = (l: Ast, r: Ast)
         | Mul = (l: Ast, r: Ast)
         | Term = (x: Int)

type Add = (l: Ast, r: Ast)
type Sub = (l: Ast, r: Ast)
type Mul = (l: Ast, r: Ast)
type Term = (x: Int)

type Ast = Add | Sub | Mul | Term

ref type Ast = Add = (l: Ast, r: Ast)
         | Sub = (l: Ast, r: Ast)
         | Mul = (l: Ast, r: Ast)
         | Term = (x: Int)

def eval = { ast: Ast ->
    match ast
        of Add(l, r) -> eval(l) + eval(r)
        of Sub(l, r) -> eval(l) - eval(r)
        of Mul(l, r) -> eval(l) * eval(r)
        of Term(x) -> x
}: Int


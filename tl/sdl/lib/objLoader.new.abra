import abra.buffers with FloatBuffer, OutOfRange
import abra.io with IOError, ReaderError
import abra.int
import abra.range

type ObjLoadError = IOError
                  | ReaderError
                  | OutOfRange

type LoadedObj = FloatBuffer # the obj model
               | ObjLoadError

type ReadLine = Ok of Unit
              | ObjLoadError

def readVertex = { buffer: FloatBuffer, line: String ->
    val reader = line.toReader
    unless ReaderError {
        reader.drop('v '.length)
        buffer.push(reader.readFloat) # x
        buffer.push(reader.readFloat) # y
        buffer.push(reader.readFloat) # z
    }

    Ok
}: ReadLine

def readTexture = { buffer: FloatBuffer, line: String ->
    val reader = line.toReader
    unless ReaderError {
        reader.drop('vt '.length)
        buffer.push(reader.readFloat) # u
        buffer.push(reader.readFloat) # v
    }

    Ok
}: ReadLine

def readNormal = { buffer: FloatBuffer, line: String ->
    val reader = line.toReader
    unless ReaderError {
        reader.drop('vn '.length)
        buffer.push(reader.readFloat) # nx
        buffer.push(reader.readFloat) # ny
        buffer.push(reader.readFloat) # nz
    }

    Ok
}: ReadLine

def readFace = { buffer: FloatBuffer, line: String, vert: FloatBuffer, tex: FloatBuffer, nl: FloatBuffer ->
    val reader = line.toReader
    reader.drop('f '.length) unless ReaderError

    (0 to 3).takeWhile[ObjLoadError]({ i ->
        val vertexId = reader.readInt unless ReaderError - 1
        reader.drop('/'.length) unless ReaderError
        val uvId = reader.readInt unless ReaderError - 1
        reader.drop('/'.length) unless ReaderError
        val normalId = reader.readInt unless ReaderError - 1

        val mesh = unless OutOfRange {
            [vert(vertexId * 3), vert(vertexId * 3 + 1), vert(vertexId * 3 + 2),
            tex(uvId * 2), tex(uvId * 2 + 1),
            nl(normalId * 3), nl(normalId * 3 + 1), nl(normalId * 3 + 2)]
        }

        buffer.append(mesh)

        Next
    }) unless ObjLoadError
}: ReadLine

def load = { fname: String ->
    val objFile = io.open(fname, 'r') unless IOError

    val vertexBuffer = buffers.mkFloat(4)
    val textureBuffer = buffers.mkFloat(4)
    val normalBuffer = buffers.mkFloat(4)
    val meshBuffer = buffers.mkFloat(4)

    objFile.lines.takeWhile[ObjLoadError]({ ioLine ->
        val line = ioLine unless IOError

        if line.startsWith('v ') then readVertex(vertexBuffer, line) unless ObjLoadError
        if line.startsWith('vt ') then readTexture(textureBuffer, line) unless ObjLoadError
        if line.startsWith('vn ') then readNormal(normalBuffer, line) unless ObjLoadError
        if line.startsWith('f ')
            then readFace(meshBuffer, line, vertexBuffer, textureBuffer, normalBuffer) unless ObjLoadError

        Next
    }) unless ObjLoadError

    objFile.close() unless IOError
    vertexBuffer.free()
    textureBuffer.free()
    normalBuffer.free()

    meshBuffer
}: LoadedObj
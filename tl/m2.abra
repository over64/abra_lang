# Example program which should compile on M2 language release
# Features:
# 1. Boolean, Int and Float literals
# 2. llvm type declarations
# 3. struct type declarations (algebraic multiplication) with visibility attribute
#   type S = {a: T1, self b: T2 }
#   S.b not visible outside. Direct object creation impossible
#   type Fd = { self handle: Int }
#   def open = llvm { path: String -> }: Fd
#   def readLine = llvm { self: Fd -> }: String
#   def close = llvm { self: Fd -> }: Unit
#   val file = open('home/1.txt')
#   file.readLine().print()
# 4. Comments via #
# 5. Function declarations with 'bracket' syntax:
#   def fn = { a: Int, b: Int ->
#       a + b
#   }: Int
# 6. Function declarations with lambda(single-expression) syntax:
#   def fn = \a: Int, b: Int -> a + b
# 7. Functions with LLVM-inline body
#   def + = llvm { a: Int, b: Int -> llvm-asm-inline }: Int
# 8. String literals (ASCII) downcastable to llvm.i8*
#   type String = llvm { i8* }
#   def print = llvm { self: String -> call C printf }
# 9. Function overloading with 'self' parameter type
# 10. expressions
#   10.1 direct calls via a.foo() 1.+(1) etc
#   10.2 infix calls
#   10.3 operators with c-like precedence:
#       + - * / || && == != < <= > >=
#   10.4 tuple expressions for initialization like: val v: Vec3 = (1, 2, 3)
#   10.5 if then else expressions in forms:
#       if cond then expression else expressions
#       if cond {
#           expr list
#       } else {
#           expr list
#       }
#   10.6 while loop expression with llvm.void return in forms:
#       while cond then expression
#       while cond {
#           expressions
#       }
#   10.7 struct fields navigation: a.b.x
#   10.8 call via navigation for implicit getters / setters implementation:
#       type S = (f: Int, g: Int)
#       # getters
#       def f = \self: S -> self.f * 2
#       val a = S(1, 2).f #expect 2
#       # setters
#       def f = \self: S, value: Int -> self.f = value
#       val s = S(1, 2)
#       s.f = 2
# 11. Simple type inference
# 12. Function literals used in expressions in forms:
#   { a1: T1, a2: T2 -> expressions }
#   \a1: T1, a2: T2 -> expression
#   where types is optional
# 13. Function types: (arg1: T1, ..., argN: Tn) -> U
# 14. Functional variables:
#   val fn : (a: Int) -> Int = \a -> a * 2
# 15. Pass function as function argument
#   def foo = { t: T, bar: (t: T) -> U -> bar(t) }


type Unit = llvm { void }
type Boolean = llvm { i1 }
type Int = llvm { i32 }
type Float = llvm { f32 }
type String = llvm { i8* }
type Vec3 = (x: Float, y: Float, z: Float)
type Fd = (self handle: Int)

def +: (self: Int, other: Int) -> Int = llvm {
  %1 = add nsw i32 %other, %self
  ret i32 %1
}

def factorial = \n: Int ->
    if n < 2 then 1
    else n * factorial(n - 1)

def factDemo = {
    val n = readInt()
    val fact = factorial(n)
    printInt(fact)
}: Unit

def booleanDemo = {
    val x = true
    val a = 'Привет, мир!\n'
    val y = false
    val e = !x && y

    printBoolean(!z == x and y)
}: Unit

def dot: (self: Vec3, v2: Vec3) -> Float = \self, v2 ->
    self.x * v2.x + self.y * v2.y + self.z * v2.z

def dot = \self: Vec3, v2: Vec3 ->
    self.x * v2.x + self.y * v2.y + self.z * v2.z

def floatDemo = {
    val v1 = Vec3(1.0, 1.0, 1.0)
    val v2 = Vec3(0.0, 1.0, 1.0)
    val d = v1 dot v2
    val dotMore =
        if d > 0.5 {
            1 + 1
            true
        }
        else {
            2 + 2
            false
        }
    dotMore.print
}: Unit

def loopDemo = {
    var i = 0
    while i < 10 {
        i.print
        i = i.+(1)
    }
}: Unit


type Fd = (self handle: Int)
def open = { path: String ->
    # blah blah blah
}: Fd

def write = { self: Fd, data: String ->
    # blah blah blah
    self
}: Fd

def close = { self: Fd ->
}: Unit

# Usage
def PATH = \ -> '/tmp/file'
def main = {
    open(PATH).write('hello, world\n').close()
}: Unit

type Range = (from: Int, to: Int)

def to = \self: Int, to: Int -> Range(self, to)

def foreach = { self: Range, fn: (x: Int) -> Unit ->
    var i = self.from
    while i < self.to {
        fn(i)
        i = i + 1
    }
}: Unit

def foreachDemo = {
    1 + 2
    (1 to 10) foreach \i -> (i * i).print

    (1 to 10) foreach \i ->
        (1 to 10) foreach \j ->
            (1 to 10) foreach \k ->
                (i + j + k).print
}: Unit

def + = \self: Vec3, v2: Vec3 -> Vec3(self.x + v2.x, self.y + v2.y, self.z + v2.z)

def tupleInitDemo = {
    val b1: Vec3 = (1, 0, 0)
    val b2: Vec3 = (0, 1, 0)
    val b3: Vec3 = (0, 0, 1)
    val some = (b1 + b2) dot b3
    val range: Range = (0, 10)

    # Future syntax for Arrays
    # val basis : Vec3[3] = (
    #   (0, 0, 1),
    #   (0, 1, 0),
    #   (1, 0, 0),
    # )
    # VS
    # val basis = Vec3[3] (
    #   Vec3(0, 0, 1),
    #   Vec3(0, 1, 0),
    #   Vec3(1, 0, 0),
    # )

    range foreach \i -> printFloat(i * some)
}: Unit

def fnPointerDemo = { i: Int, j: Int ->
    val i = readInt()
    val mapInt: (i: Int) -> Int =
        if i mod 2 == 0 then \i -> i + 1
        else \i -> i * i

    val mapInt2 : (fn: (i: Int) -> Int, i: Int) -> Int = \fn, i -> fn(i) + 2
    val mapInt22 = \fn: (i: Int) -> Int, i: Int -> fn(i) + 2

    readInt().mapInt.print
} : Unit

def main = {
    { x: Int, y: Int ->
        (x + y).print
    }(1, 2)

    factDemo()
    booleanDemo()
    floatDemo()
    loopDemo()
    foreachDemo()
    tupleInitDemo()
    fnPointerDemo()

    0
}: Int
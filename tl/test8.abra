type Unit = llvm { void }
type Int = llvm { i32 }
type Vec3i = (x: Int, y: Int, z: Int)

def vec3i: (x: Int, y: Int, z: Int) -> Vec3i = llvm {

}

def +: (self: Int, other: Int) -> Int = llvm {
  %1 = add nsw i32 %other, %self
  ret i32 %1
}

def vec3i = llvm { x: Int, y: Int, z: Int ->
    %1 = getelementptr %struct.Vec3i, %struct.Vec3i* %ret, i32 0, i32 0
    store i32 %x, i32* %1

    %2 = getelementptr %struct.Vec3i, %struct.Vec3i* %ret, i32 0, i32 1
    store i32 %y, i32* %2

    %3 = getelementptr %struct.Vec3i, %struct.Vec3i* %ret, i32 0, i32 0
    store i32 %z, i32* %3

    ret void
}: Vec3i

def printInt = llvm { i: Int ->
    %str = alloca [4 x i8], align 1
    store [4 x i8] c"%d\0A\00", [4 x i8]* %str, align 1
    %1 = getelementptr [4 x i8], [4 x i8]* %str, i32 0, i32 0
    %2 = call i32 (i8*, ...) @printf(i8* %1, i32 %i)
    ret void
}: Unit

def main = {
    val a: Int = 1
    a + 1 * 3
    2
    val v: Vec3i = vec3i(2,3,1)
    val b: Int  = a * 10 + 1 + v.y * 2
    printInt(b)
    b
    0
}: Int

def + = llvm { self: Int, other: Int ->
  %1 = add nsw i32 %other, %self
  ret i32 %1
}: Int

def * = llvm { self: Int, other: Int ->
  %1 = mul nsw i32 %other, %self
  ret i32 %1
}: Int
# patterm matching ?

val array: Int[] = (0, 1, 2, 3, 4, 5)

def sumRec = { self: Int[] ->
    match self
        of (head, tail..) -> head + tail.sumRec
        of (head) -> head
        of () -> 0 end
}: Int

# или просто  так
def sumRec = { self: Int[] ->
    of (head, tail..) -> head + tail.sumRec
    of (head) -> head
    of () -> 0
}: Int

module IO = {
    type Resource<T> = Ok of T | Error of String

    def orPanic<T> = { self: Resource<T> ->
        of ok: Ok -> ok
        of err: Error -> panic(err)
    }: T

    type IO<T> = Ok of T | Error of String

    def orPanic<T> = { self: IO<T> ->
        of ok: Ok -> ok
        of err: Error -> panic(err)
    }: T

    def STDIN = fd(1)
    def open = { path: String -> }: Resource<Fd>
    def readLine = { self fd: Fd = STDIN, maxLength = 4096 -> }: IO<String>

    type Release = Ok of Unit | Error of String
    def close = {self: Fd -> }: Release

    def withFile<T> = { path: String, f: (fd: Fd) -> T ->
        match open(path)
            of fd: Ok ->
                f(fd)
                match fd.close
                    of str: Error -> panic(str)
                    else end
            of str: Error -> panic(str) end
    }

    # raw read allowed only for value types?
    def readRaw<value T>: (self: Fd) -> T = llvm {
     ; LLVM AND GENERIC BLACK MAGIC?
    }
}

type Porn : Soft of (a1: Int, a2: Int) | Hard of (a1: Int, a2: Int)
def doStaff = { self: Porn ->
    of Soft -> 'soft'
    of Hard -> 'hard'
}: String

type PornIndustry = (rand: Rand = Rand())
type PornCreator = (a1: Int, a2: Int) -> Porn
def create = \self: PornCreator -> self()

def fabric = { self: PornIndustry ->
    if self.rand then \a1, a2 -> Soft(a1, a2)
    else \a1, a2 -> Hard(a1, a2)
}: PornCreator

def main = {
    val industry = PornIndustry()
    (1 to 1000).map \i -> industry.fabric.create(i, i + 1)
        .foreach \p -> p.doStaff.println
}: Unit

# Noob way
val fd = open('/tmp/file').orPanic
val str = fd.readLine().orPanic
fd.close()
# Correct way
type Vec3 = (x: Float, y: Float, z: Float)
val lines = withFile('/tmp/file', { fd ->
    val vec = fd.readRaw<Vec3>()
    fd.readLines
}).orPanic


# tranceducers collections?
module Iterator<T> {
    type Iterator = (src: T[], idx)
    type Value = T | None of Unit

    def apply = { self: Iterator ->
        idx += 1
        if self.idx > self.src then None
        else src(idx)
    }: Value
}
module Collection<T> {
    def map<U> = { self: () -> T, mapFn: (v: T) -> U ->
        mapFn(self())
    }
}
# автоматический каст выражения к лямбде?
[1, 2, 3].iterator.map(\x -> x * 2).filter(\x -> x % 2 == 0).take(10)
take(filter(map([1, 2, 3].iterator, \x -> x * 2), \x -> x % 2 == 0), 10)
[1, 2, 3].transform { map(\x -> x * 2).filter(\x -> x % 2 == 0).take(10) }.foreach { i ->

}

#Sized generics ?
module Mat<T, n1, n2> = {
    + : (self: T, other: T) -> T,
    * : (self: T, other: T) -> T ->

    type Mat = (array: T[n1 * n2])

    def + = { self: Mat, m2: Mat ->

    }

    def *<n3> = { self: Mat, m2: Mat<T, n2, n3> ->

    }: Mat<n1, n3>
}

# Usage:
import Mat<Int>

val mat1: Mat<1,2> = (
    0, 1
)

val mat2: Mat<2,1> = (
    1,
    1
)

val mat3 = (mat1 + mat1) * mat2 #Mat<1,1>

# no mutability for value types
# mutation of variables via `where` clause

# Power of typeclasses!
type lInt = (value: String)
type lFloat = (value: String)
type lString = (value: String)

type Literal = lInt | lFloat | lString

type Type = Scalar of String
          | Struct of (name: String, fields: Type[])


type Vec3 = (x: Float, y: Float, z: Float)

val v1 = Vec3(0,0,0)
val v2 = v1 where x = x + 1

# equals to
val v2 = v1
v2.x = v1.x + 1
# or
val v2 = Vec3(v1.x + 1, v1.y, v1.z)

var v = Vec3(0,0,0)

(1 to 100) foreach { i ->
    v = v where { x = x + i, y = y * i }
}

# Mutable 'Hello, world'
type Foo = (x: Int)

def main = {
    val f1 = Foo(1)
    val f2 = f1 where x = x + 1

    println('Hello, mutation! f2.x is \{f2.x}')
}: Unit

# ultra feature
type Session = (userName: FixedString<34>)
type User = (name: String, age: Int)

type Responses = String | User

module HttpServer<T> { mkSession: () -> T ->

    module Mount<T, U> { serialize: (userResponse: U) -> String ->
            type Method = GET of Unit | POST of Unit
            type Route = (method: Method, handler: (session: T, request: Request) -> Ret)

        type Mount = (path: String, handler: )
                    def get = \path: String, handler: (session: T, request: Request) -> Ret ->
                        Route(GET, path, handler)
    }

    type Ret = (session: T, response: Response)
    type Header = (name: String, value: String)
    type Response = (headers: Header[], data: U)
    type HttpResponse = (headers: Header[], raw: String)
}

import HttpServer<Session> {
    mkSession = \ -> Session()
    import Mount<Responses> {
        serialize = \resp -> resp.toJson
    }
}

listen(
    address = '127.0.0.1:9000',
    mounts = (
        Mount {
            root= '/',
            routes = (
                get('/', { session, request ->
                    val new_session = session where userName = 'over'
                    (new_session, {data = 'Hello, %username%'})
                })
            ),
            after = { response ->
                response where headers = headers + ("Content-Type", "application/json")
            }
        }
    )
)

# wtf ?
type List<T> = Nil of Unit | Node(head: T, tail: List<T>)
val list: Node<String> = ('мама', ('мыла', ("раму", Nil)))
val list2 = list where
    where tail = tail
        where head = "помыла"

val a2 = a1 where {
    [0] = [3]
}

# task-based concurrency ?

module Chan<n1, T> = {
    import Mutex
    type Slot = T | None of Unit
    type Chan = (self mutex: Mutex, self slots: Slot[n1])

    def mkChan = {

    }: Chan

    def read = { self: Chan ->

    }: T

    def takeWhile = { self: Chan, predicate: (message: T) -> Boolean ->
        while true {
            val msg = self.read()
            if !predicate(msg) then break
        }
    }: Unit
}

type Message = String | EOF of Unit
import Chan<10, Message>

def main = {
    val chan = mkChan()

    withFile('/tmp/file', 'r') {
        file.eachLine \line -> chan.write(line)
        chan.write(EOF)
    }.fork

    chan.takeWhile {
        case line: String -> line.println ; true
        case EOF -> false
    }
}

#
map, filter, take: collection -> collection
(1 to INT_INF).apply(map(\x -> x * 2).filter(\x -> x % 3).take(100))
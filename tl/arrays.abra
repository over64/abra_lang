type Unit = llvm { void }
type Boolean = llvm { i1 }
type Int = llvm { i32 }
type IntArray = llvm { i32* }

def +: (self: Int, other: Int) -> Int = llvm {
  %1 = add nsw i32 %other, %self
  ret i32 %1
}
def *: (self: Int, other: Int) -> Int = llvm {
  %1 = mul nsw i32 %other, %self
  ret i32 %1
}
def <: (self: Int, other: Int) -> Boolean = llvm {
  %1 = icmp slt i32 %self, %other
  ret i1 %1
}

def allocIntArray : (size: Int) -> IntArray = llvm {
  %1 = mul nsw i32 %size, 4
  %2 = call i8* @malloc(i32 %1)
  %3 = bitcast i8* %2 to i32*
  ret i32* %3
}

def set: (self: IntArray, index: Int, value: Int) -> Unit = llvm {
  %1 = getelementptr i32, i32* %self, i32 %index
  store i32 %value, i32* %1
  ret void
}

def apply: (self: IntArray, index: Int) -> Int = llvm {
  %1 = getelementptr i32, i32* %self, i32 %index
  %2 = load i32, i32* %1
  ret i32 %2
}

def free : (self: IntArray) -> Unit = llvm {
  %1 = bitcast i32* %self to i8*
  call void @free(i8* %1)
  ret void
}

def mkIntArray = { size: Int, init: (index: Int) -> Int ->
  val array = allocIntArray(10)
  var i = 0
  while i < 10 {
    array.set(i, init(i))
    i = i + 1
  }

  array
}: IntArray

def main = {
  val array = mkIntArray(10, \i -> i + 1)
  var i = 0
  var sum = 0

  while i < 10 {
    sum = sum + array.apply(i)
    i = i + 1
  }

  array.free
  sum
}: Int
import abra.int

type IntPtr = llvm { i32* }

def allocIntPtr : (size: Int) -> IntPtr = llvm {
  %1 = mul nsw i32 %size, 4
  %2 = call i8* @malloc(i32 %1)
  %3 = bitcast i8* %2 to i32*
  ret i32* %3
}

def set: (self: IntPtr, index: Int, value: Int) -> Unit = llvm {
  %1 = getelementptr i32, i32* %self, i32 %index
  store i32 %value, i32* %1
  ret void
}

def get: (self: IntPtr, index: Int) -> Int = llvm {
  %1 = getelementptr i32, i32* %self, i32 %index
  %2 = load i32, i32* %1
  ret i32 %2
}

def free : (self: IntPtr) -> Unit = llvm {
  %1 = bitcast i32* %self to i8*
  call void @free(i8* %1)
  ret void
}

type IntArray = (length: Int, ptr: IntPtr)

def get = \self: IntArray, index: Int -> self.ptr(index)

def set = \self: IntArray, index: Int, value: Int -> self.ptr(index) = value

def free = \self: IntArray -> self.ptr.free

def mkIntArray = { size: Int, init: (index: Int) -> Int ->
  val ptr = allocIntPtr(size)
  var i = 0
  while i < size {
    ptr(i) = init(i)
    i = i + 1
  }

  IntArray(size, ptr)
}: IntArray
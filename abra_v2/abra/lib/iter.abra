import
    /universe with None, Bool .

type Map[iterable, t, u] = (it: iterable, mapper: (t) -> u)
type MapIter[iterator, t, u] = (iter: iterator, mapper: (t) -> u)

type Filter[iterable, t] = (it: iterable, predicate: (t) -> bool)
type FilterIter[iterator, t] = (it: iterable, predicate: (t) -> bool)

# iterable :: iterator() -> a1
#       a1 :: next() -> a2
def isIterable = it: iterable do
    iter = it.iterator()  # iterable must provide iterator
    iter.next() . # iterator must provide t | None via next function


# lazy type inference? Higher kinded types?
# iterable :: foo() -> a1
# iterable :: iterator() -> a2
#       a2 :: next() -> t | None
def map = self: iterable, mapper: (t) -> u do
    self.foo()
    if false do
        value: t | None = isIterable(self) .
        # real = value unless is None return . # real is t
        # real + 1
    Map(self, mapper) .


def iterator = self: Map[iterable, t, u] do
    MapIter(self.it.iterator(), self.mapper) .

def next = self: MapIter[iterator, t, u] do
    value: t | None = self.iter.next()
    unless is forMap: t do
        self.mapper(forMap) ..u | None

def filter = self: iterable, predicate: (t) -> Bool do
    if false do
        value: t | None = isIterable(self) .
    Filter(self, predicate) .

def iterator = self: Filter[iterator, t] do
    FilterIter(self.it.iterator(), predicate) .

def next = self: FilterIter[iterator, t] do
    value: t | None = self.iter.next()
    unless is forFilter: t do
        if self.predicate(forFilter) do forFilter else none ..u | None



#def next = self: MapIter[iterator, t, u] do
#    if self.iter.next() not None do
#        self.mapper(value) ..u | None
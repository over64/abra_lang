import /universe with None, Bool, Int .

type Array[t] = ref llvm %t* .
#def main =
#    nums = seq.of(
#        (0, 1, 2, 3, 4, 5),
#        (0, 1, 2, 3, 4, 5),
#        (0, 1, 2, 3, 4, 5)) # Seq3x5[Int]
#
#    x = nums.get(0, 0)
#    nums.iter().forEach with 位 x ->
#        x + 1
#
#    dyn = seq.gen(10, 5, 2, 位 i, j -> 0) # Seq10x5x2[Int]
#
#    pyramid = seq.alloc with k, 位 i ->
#        seq.alloc(i + 1, 位 j -> 0) # Seq[Seq[Int]]

def alloc = length: Int do llvm
  %ptr = getelementptr %t, %t* null, i32 %length
  %sizeNoLength = ptrtoint %t* %ptr to i64
  %size = add nsw i64 %sizeNoLength, 4
  %alloc = load i8* (i64)*, i8* (i64)** @rcAlloc
  %mem = call i8* %alloc(i64 %size)
  %lcast = bitcast i8* %mem to i32*
  %lptr = getelementptr i32, i32* %lcast, i32 0
  store i32 %length, i32* %lptr
  %larray = getelementptr i32, i32* %lcast, i32 1
  %array = bitcast i32* %larray to %t*
  ret %t* %array .Array[t]

def acquire = self: Array[t] do llvm
  %cast32 = bitcast %"Array[t]" %self to i32*
  %realPtr = getelementptr i32, i32* %cast32, i32 -1
  %cast = bitcast i32* %realPtr to i8*
  %incFn = load void (i8*)*, void (i8*)** @rcInc
  call void %incFn(i8* %cast)
  ret void .None

def childFree = array: Array[t] do llvm
  %cast32 = bitcast %"Array[t]" %array to i32*
  %length = load i32, i32* %cast32
  %dataPtr = getelementptr i32, i32* %cast32, i32 1
  %data = bitcast i32* %dataPtr to %"Array[t]"

  %i = alloca i32
  store i32 0, i32* %i
  br label %head
head:
  %iv = load i32, i32* %i
  %cond = icmp eq i32 %iv, %length
  br i1 %cond, label %end, label %free
free:
  %tPtr = getelementptr %t, %t* %data, i32 %iv
  %tValue = load %t, %t* %tPtr
  call void @t.release(%t %tValue)
  %ii = add nsw i32 %iv, 1
  store i32 %ii, i32* %i
  br label %head
end:
  ret void .None

def lowRelease = self : Array[t],
                    cFree: (Array[t]) -> None do llvm
  %cast32 = bitcast %"Array[t]" %self to i32*
  %realPtr = getelementptr i32, i32* %cast32, i32 -1
  %cast = bitcast i32* %realPtr to i8*
  %freeFn = load void (i8*, void (i8*)*)*, void (i8*, void (i8*)*)** @rcRelease
  %cFree.fn = extractvalue { void (%"Array[t]", i8*)*, i8* } %cFree, 0
  %cFree.cast = bitcast void (%"Array[t]", i8*)* %cFree.fn to void (i8*)*
  call void %freeFn(i8* %cast,  void (i8*)* %cFree.cast)
  ret void .None

def release = self: Array[t] do
  spec = lambda array: Array[t] -> childFree(array) .
  self.lowRelease(spec) .None

def set = self: Array[t], idx: Int, value: t do llvm
  %ptr = getelementptr %t, %t* %self, i32 %idx
  %old = load %t, %t* %ptr
  call void @t.acquire(%t %value)
  call void @t.release(%t %old)
  store %t %value, %t* %ptr
  ret void .None

def setInit = self: Array[t], idx: Int, value: t do llvm
  %ptr = getelementptr %t, %t* %self, i32 %idx
  %old = load %t, %t* %ptr
  call void @t.acquire(%t %value)
  store %t %value, %t* %ptr
  ret void .None

def get = self: Array[t], idx: Int do llvm
  %ptr = getelementptr %t, %t* %self, i32 %idx
  %value = load %t, %t* %ptr
  ret %t %value .t

def len = self: Array[t] do llvm
  %1 = bitcast %t* %self to i32*
  %lenPtr = getelementptr i32, i32* %1, i32 -1
  %len = load i32, i32* %lenPtr
  ret i32 %len .Int

def copy = from: Array[t], to: Array[t],
              fromIdx: Int, toIdx: Int, n: Int do llvm
  %fromOffset = getelementptr %t, %t* %from, i32 %fromIdx
  %fromPtr = bitcast %t* %fromOffset to i8*
  %toOffset = getelementptr %t, %t* %to, i32 %toIdx
  %toPtr = bitcast %t* %toOffset to i8*

  %sizeofPtr = getelementptr %t, %t* null, i32 1
  %sizeof = ptrtoint %t* %sizeofPtr to i64
  %n64 = zext i32 %n to i64
  %size = mul nsw i64 %n64, %sizeof
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %toPtr, i8* %fromPtr, i64 %size, i32 0, i1 false)
  ret void .None

def mk = length: Int, init: (Int) -> t do
  array: Array[t] = alloc(length)

  i = 0
  while i < length do
    array.setInit(i, init(i))
    i = i + 1 .

  array .

type ArrayIter[t] = (array: Array[t], idx: Int)

def iterator = self: Array[t] do
    ArrayIter(self, 0) .

def next = self: ArrayIter[t] do
    if self.idx < self.array.len() do
        self.idx = self.idx + 1
        self.array.get(self.idx - 1)
    else none ..
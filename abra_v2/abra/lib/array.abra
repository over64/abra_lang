import /universe with None, Bool, Int, String, Float .

type Array[T] = ref llvm %T* .

def lowAlloc[T] = length: Int do llvm
  %ptr = getelementptr %T, %T* null, i32 %length
  %sizeNoLength = ptrtoint %T* %ptr to i64
  %size = add nsw i64 %sizeNoLength, 4
  %alloc = load i8* (i64)*, i8* (i64)** @rcAlloc
  %mem = call i8* %alloc(i64 %size)
  %lcast = bitcast i8* %mem to i32*
  %lptr = getelementptr i32, i32* %lcast, i32 0
  store i32 %length, i32* %lptr
  %larray = getelementptr i32, i32* %lcast, i32 1
  %array = bitcast i32* %larray to %T*
  ret %T* %array .Array[T]


def acquire[T] = self: Array[T] do llvm
  %cast32 = bitcast %"Array[T]" %self to i32*
  %realPtr = getelementptr i32, i32* %cast32, i32 -1
  %cast = bitcast i32* %realPtr to i8*
  %incFn = load void (i8*)*, void (i8*)** @rcInc
  call void %incFn(i8* %cast)
  ret void .None

def childFree[T] = array: Array[T] do llvm
  %cast32 = bitcast %"Array[T]" %array to i32*
  %length = load i32, i32* %cast32
  %dataPtr = getelementptr i32, i32* %cast32, i32 1
  %data = bitcast i32* %dataPtr to %"Array[T]"

  %i = alloca i32
  store i32 0, i32* %i
  br label %head
head:
  %iv = load i32, i32* %i
  %cond = icmp eq i32 %iv, %length
  br i1 %cond, label %end, label %free
free:
  %tPtr = getelementptr %T, %T* %data, i32 %iv
  %t = load %T, %T* %tPtr
  call void @T.release(%T %t)
  %ii = add nsw i32 %iv, 1
  store i32 %ii, i32* %i
  br label %head
end:
  ret void .None

def lowRelease[T] = self : Array[T],
                    cFree: (Array[T]) -> None do llvm
  %cast32 = bitcast %"Array[T]" %self to i32*
  %realPtr = getelementptr i32, i32* %cast32, i32 -1
  %cast = bitcast i32* %realPtr to i8*
  %freeFn = load void (i8*, void (i8*)*)*, void (i8*, void (i8*)*)** @rcRelease
  %cFree.fn = extractvalue { void (%"Array[T]", i8*)*, i8* } %cFree, 0
  %cFree.cast = bitcast void (%"Array[T]", i8*)* %cFree.fn to void (i8*)*
  call void %freeFn(i8* %cast,  void (i8*)* %cFree.cast)
  ret void .None

def release[T] = self: Array[T] do
  spec = lambda array: Array[T] -> childFree(array) .
  self.lowRelease(spec) .None

def set[T] = self: Array[T], idx: Int, value: T do llvm
  %ptr = getelementptr %T, %T* %self, i32 %idx
  %old = load %T, %T* %ptr
  call void @T.acquire(%T %value)
  call void @T.release(%T %old)
  store %T %value, %T* %ptr
  ret void .None

def setInit[T] = self: Array[T], idx: Int, value: T do llvm
  %ptr = getelementptr %T, %T* %self, i32 %idx
  %old = load %T, %T* %ptr
  call void @T.acquire(%T %value)
  store %T %value, %T* %ptr
  ret void .None

def get[T] = self: Array[T], idx: Int do llvm
  %ptr = getelementptr %T, %T* %self, i32 %idx
  %value = load %T, %T* %ptr
  ret %T %value .T

def len[T] = self: Array[T] do llvm
  %1 = bitcast %T* %self to i32*
  %lenPtr = getelementptr i32, i32* %1, i32 -1
  %len = load i32, i32* %lenPtr
  ret i32 %len .Int

def copy[T] = from: Array[T], to: Array[T],
              fromIdx: Int, toIdx: Int, n: Int do llvm
  %fromOffset = getelementptr %T, %T* %from, i32 %fromIdx
  %fromPtr = bitcast %T* %fromOffset to i8*
  %toOffset = getelementptr %T, %T* %to, i32 %toIdx
  %toPtr = bitcast %T* %toOffset to i8*

  %sizeofPtr = getelementptr %T, %T* null, i32 1
  %sizeof = ptrtoint %T* %sizeofPtr to i64
  %n64 = zext i32 %n to i64
  %size = mul nsw i64 %n64, %sizeof
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %toPtr, i8* %fromPtr, i64 %size, i32 0, i1 false)
  ret void .None

def alloc[T] = len: Int do
    array = lowAlloc[T](len)
    # hacky way to spec acquire / release functions
    if false do
        array.acquire()
        array.release() .

    array .

def mk[T] = length: Int, init: (Int) -> T do
  array = alloc[T](length)

  i = 0
  while i < length do
    array.setInit(i, init(i))
    i = i + 1 .

  array .
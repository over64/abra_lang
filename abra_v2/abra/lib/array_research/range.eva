type Range[t] = (from: t, to: t, step: t)
type RangeIter[t] = (rng: Range[t], curr: t)

def contract = equation: () -> u do none .

def canRange = x: t do
  cmpRule: Bool = x < x
  addRule: t = x + x
  zeroRule: t = x.zero()
  oneRule: t = x.one() .

def of = from: t, to: t, step: t do
  contract(-> canRange(from))
  Range(from, to) .

def to = self: t, to: t do
  contract(-> canRange(from))
  Range(from, to, from.one()) .

def iter = self: Range[t] do
  RangeIter(self, self.from) .

def next = self: RangeIter[t] do
  next: t = self.curr + self.range.step
  if next < self.range.to do
    self.curr = next
    next
  else none .t | None

def times = self: t, action: (t) -> None do
  i: t = self.zero()
  while i < self do
    action(i)
    i = i + self.one() .



# usage
import /range .
0h123123i
0b1111us
0o116s

100b 100ub
100s 100us
100i 100ui
100l 100ul
100f
100d

1ub 1b

100i8 100u8
100i16 100u16
100i32 100u32
100l64 100u64
100f32
100f64

Bin1
Bin2
Bin3
Bin4
..
Bin32
Bin64


def main =
  range.of(0, 100, 2) forEach \i ->
    fmt.write(io.stdout, i)

  (0 to 100) forEach \i ->
      fmt.write(io.stdout, i)


  (0s to 1024) forEach \i ->
      fmt.write(io.stdout, i)

  nums = (0 to 100).iter().map(\i -> i * 2).toArray()

  100 times \i ->
    fmt.write(io.stdout, i)

# partial eval array maker
# varargs is hard problem
def of = args: t do
  stti.typeof(args) unless
    s: AnonStruct do
      nop: ft = stti.inferSuperType(s.fields)
      inst: Array[ft] = unsafeArray.alloc(s.fields.len())
      s.fields enumerated \(f, i) ->
        arg = unsafe.tupleField(args, i)
        unsafeArray.setInit(inst, i, arg)
      inst
    else E('expected tuple of args like `array.of((1, 2, 3))`')

def of = args: t do
  inst: Array[Int] = unsafeArray.alloc(4)
  (0 to 4) forEach \i ->
    arg = unsafe.tupleField(args, i)
    unsafeArray.setInit(inst, i, arg)
  inst




# usage
def main =
  nums = array.of((1, 2, 3, 5))

  nums2 = array.of((
    array.of((1, 2, 3, 5)),
    array.of((1, 2, 3, 5)),
    array.of((1, 2, 3, 5))
  ))

  buff = array.buffer(4096, 0)
llvm
  @.printfInt = private constant [3 x i8] c"%d\00", align 1
  @.printfStr = private constant [3 x i8] c"%s\00", align 1
  declare i32 @printf(i8*,...)
  declare i32 @puts(i8*)
  @pool = thread_local global %MemPool zeroinitializer
  define void @poolRelease(i8* %obj, void (i8*)* %releaseCallback) {
    ret void
  }
  .

type None = llvm void .
type Bool = llvm i8 .
type Int  = llvm i32 .
type Long = llvm i64 .
type String = ref llvm i8* .

def + = self: Int, other: Int -> llvm
  %1 = add nsw i32 %self, %other
  ret i32 %1 .Int

def - = self: Int, other: Int -> llvm
  %1 = sub nsw i32 %self, %other
  ret i32 %1 .Int

def > = self: Int, other: Int -> llvm
  %1 = icmp sgt i32 %self, %other
  %2 = zext i1 %1 to i8
  ret i8 %2 .Bool

def < = self: Int, other: Int -> llvm
  %1 = icmp slt i32 %self, %other
  %2 = zext i1 %1 to i8
  ret i8 %2 .Bool

def shl = self: Int, shift: Int -> llvm
  %1 = shl i32 %self, %shift
  ret i32 %1 .Int

def toLong = self: Int -> llvm
  %1 = zext i32 %self to i64
  ret i64 %1 .Long

def add = self: Long, other: Long -> llvm
  %1 = add nsw i64 %self, %other
  ret i64 %1 .Long

def >= = self: Long, other: Long -> llvm
  %1 = icmp sge i64 %self, %other
  %2 = zext i1 %1 to i8
  ret i8 %2 .Bool

def <= = self: Long, other: Long -> llvm
  %1 = icmp sle i64 %self, %other
  %2 = zext i1 %1 to i8
  ret i8 %2 .Bool

def print = self: String -> llvm
  %format = bitcast [3 x i8]* @.printfStr to i8*
  call i32 (i8*,...) @printf(i8* %format, i8* %self)
  ret void .None

def printInt = self: Int -> llvm
    %format = bitcast [3 x i8]* @.printfInt to i8*
    call i32 (i8*,...) @printf(i8* %format, i32 %self)
    ret void .None

type Range = (from: Int, to: Int, step: Int)

def each = self: Range, fn: \Int -> None ->
  i = self.from
  while i < self.to do
    fn(i)
    i = i + self.step ..

type Ptr = llvm i8* .
type Allocator = (alloc  : \Long -> Ptr,
                  inc    : \Ptr -> None,
                  release: \Ptr, \Ptr -> None -> None)


def loadAlloc = llvm
  %a = alloca %Allocator

  %a.alloc   = getelementptr %Allocator, %Allocator* %a, i64 0, i32 0
  %a.inc     = getelementptr %Allocator, %Allocator* %a, i64 0, i32 1
  %a.release = getelementptr %Allocator, %Allocator* %a, i64 0, i32 2

  %old.alloc   = load i8* (i64)*,  i8* (i64)**   @rcAlloc
  %old.inc     = load void (i8*)*, void (i8*)**  @rcInc
  %old.release = load void (i8*, void (i8*)*)*, void (i8*, void (i8*)*)**    @rcRelease

  store i8* (i64)* %old.alloc, i8* (i64)**  %a.alloc
  store void (i8*)* %old.inc, void (i8*)**  %a.inc
  store void (i8*, void (i8*)*)* %old.release, void (i8*, void (i8*)*)**  %a.release

  %ret = load %Allocator, %Allocator* %a
  ret %Allocator %ret .Allocator

def storeAlloc = alloc: Allocator -> llvm
  %a = load %Allocator, %Allocator* %alloc
  %a.alloc   = extractvalue %Allocator %a, 0
  %a.inc     = extractvalue %Allocator %a, 1
  %a.release = extractvalue %Allocator %a, 2

  store i8* (i64)* %a.alloc, i8* (i64)**  @rcAlloc
  store void (i8*)* %a.inc, void (i8*)**  @rcInc
  store void (i8*, void (i8*)*)* %a.release, void (i8*, void (i8*)*)**  @rcRelease

  ret void .None


type MemPage = llvm {i8*, i64}* .

def mkMemPage = llvm
  %1 = load i8* (i64)*, i8* (i64)** @rcAlloc
  %2 = call i8* %1(i64 4050) ; 1 page 1048576
  %mp = bitcast i8* %2 to {i8*, i64}*

  %mp.next = getelementptr {i8*, i64}, {i8*, i64}* %mp, i64 0, i32 0
  store i8* null, i8** %mp.next

  %mp.offset = getelementptr {i8*, i64}, {i8*, i64}* %mp, i64 0, i32 1
  store i64 32, i64* %mp.offset ;  8 + 8 + 8 see data layout for MemPage

  ret {i8*, i64}* %mp .MemPage

def chain = self: MemPage, child: MemPage -> llvm
  %1 = getelementptr {i8*, i64}, {i8*, i64}* %self, i64 0, i32 0
  %2 = bitcast {i8*, i64}* %child to i8*
  store i8* %2, i8** %1
  ret void .None

def mpFreeInner = self: Ptr -> llvm
  ret void .None

def mpFree = self: MemPage -> llvm
  %selfAddr = ptrtoint {i8*, i64}* %self to i64
  %nullCheck = icmp eq i64 %selfAddr, 0
  br i1 %nullCheck, label %endNull, label %begin
endNull:
  ret void
begin:
  %1 = getelementptr {i8*, i64}, {i8*, i64}* %self, i64 0, i32 0
  %2 = load i8*, i8** %1
  %3 = bitcast i8* %2 to {i8*, i64}*

  %child = ptrtoint i8* %2 to i64
  %isNull = icmp eq i64 %child, 0
  br i1 %isNull, label %end, label %freeChild
freeChild:
  call void @mpFree({i8*, i64}* %3)
  br label %end
end:
  %4 = bitcast {i8*, i64}* %self to i8*
  %5 = load void (i8*, void (i8*)*)*, void (i8*, void (i8*)*)** @rcRelease
  call void %5(i8* %4, void (i8*)* @mpFreeInner)
  ret void .None

def nextPage = self: MemPage -> llvm
  %1 = getelementptr {i8*, i64}, {i8*, i64}* %self, i64 0, i32 0
  %2 = load i8*, i8** %1
  %3 = bitcast i8* %2 to {i8*, i64}*
  ret {i8*, i64}* %3 .MemPage

def offset = self: MemPage -> llvm
  %offsetPtr  = getelementptr {i8*, i64}, {i8*, i64}* %self, i64 0, i32 1
  %offset = load i64, i64* %offsetPtr
  ret i64 %offset .Long

def setOffset = self: MemPage, offset: Long -> llvm
  %offsetPtr  = getelementptr {i8*, i64}, {i8*, i64}* %self, i64 0, i32 1
  store i64 %offset, i64* %offsetPtr
  ret void .None

def alloc = self: MemPage, newOffset: Long -> llvm
  %offsetPtr  = getelementptr {i8*, i64}, {i8*, i64}* %self, i64 0, i32 1
  %offset = load i64, i64* %offsetPtr
  store i64 %newOffset, i64* %offsetPtr

  %1 = ptrtoint {i8*, i64}* %self to i64
  %2 = add nsw i64 %1, %offset
  %objPtr = inttoptr i64 %2 to i8*
  ret i8* %objPtr .Ptr


type MemPool = (parent: Allocator, root: MemPage)
def mkMemPool = MemPool(loadAlloc(), mkMemPage()) .

def mkPoolAlloc = llvm
  %a = alloca %Allocator

  %a.alloc   = getelementptr %Allocator, %Allocator* %a, i64 0, i32 0
  %a.inc     = getelementptr %Allocator, %Allocator* %a, i64 0, i32 1
  %a.release = getelementptr %Allocator, %Allocator* %a, i64 0, i32 2

  store i8* (i64)* @poolAlloc, i8* (i64)**  %a.alloc
  store void (i8*)* @poolInc, void (i8*)**  %a.inc
  store void (i8*, void (i8*)*)* @poolRelease, void (i8*, void (i8*)*)**  %a.release

  %ret = load %Allocator, %Allocator* %a
  ret %Allocator %ret .Allocator

def bind = self: MemPool -> llvm
  %1 = load %MemPool, %MemPool* %self
  store %MemPool %1, %MemPool* @pool
  ret void .None

def loadPool = llvm
  %1 = load %MemPool, %MemPool* @pool
  ret %MemPool %1 .MemPool

def loadRoot = llvm
  %1 = getelementptr %MemPool, %MemPool* @pool, i64 0, i32 1
  %2 = load {i8*, i64}*, {i8*, i64}** %1
  ret {i8*, i64}* %2 .MemPage

def poolAlloc = size: Long ->
  root = loadRoot()
  rootNewOffset = root.offset() add size

  if rootNewOffset <= 4050.toLong() do #1048576
    root.alloc(rootNewOffset)
  else
    pool = loadPool()
    curr = loadAlloc()
    storeAlloc(pool.parent)
    newPage = mkMemPage()
    storeAlloc(curr)

    pool.root = newPage
    root.chain(newPage)
    pool.bind()
    newOffset = newPage.offset() add size
    newPage.alloc(newOffset) ..Ptr

def poolInc = obj: Ptr -> llvm
  ret void .None

def poolFree = self: MemPool ->
  root = self.root
  root.setOffset(32.toLong())
  next = root.nextPage()
  next.mpFree() .

def withPool = self: MemPool, action: -> None ->
  curr = mkPoolAlloc()

  self.bind()
  storeAlloc(curr)
  action()
  storeAlloc(self.parent)
  self.poolFree() .


type Node = (left: Node | None, right: Node | None)

def asNode = self: Node | None, callback: \Node -> None -> llvm
  %1 = getelementptr { void (%"Node"*, i8*)*, i8* }, { void (%"Node"*, i8*)*, i8* }* %callback, i64 0, i32 0
  %fn = load void (%"Node"*, i8*)*, void (%"Node"*, i8*)** %1
  %2 = bitcast { void (%"Node"*, i8*)*, i8* }* %callback to i8*
  %3 = load %Node*, %Node** %self
  call void %fn(%Node* %3, i8* %2)
  ret void .None

def mkTree = depth: Int ->
  if depth > 0 do
    Node(mkTree(depth - 1), mkTree(depth - 1))
  else
    Node(none, none) ..Node

def checksum = self: Node ->
  sum = 1

  when self.left  is l: Node do
     self.right asNode lambda r: Node ->
       sum = sum + l.checksum() + r.checksum() .

  sum .Int

def main =
  minDepth = 4
  maxDepth = 21 # sys.arg(0).toInt()

  if maxDepth < minDepth + 2 do
    maxDepth = minDepth + 2 .

  tree = mkTree(maxDepth + 1)
  print('stretch tree of depth '); printInt(maxDepth + 1); print('\t check: '); printInt(tree.checksum()); print('\n')

  llTree = mkTree(maxDepth)
  print('long lived tree of depth '); printInt(maxDepth); print('\t check: '); printInt(llTree.checksum()); print('\n')

  Range(minDepth, maxDepth, 2) each lambda depth: Int ->
    iters    = 1 shl (maxDepth + minDepth - depth)
    totalSum = 0

    Range(1, iters + 1, 1) each lambda i: Int ->
      totalSum = totalSum + mkTree(depth).checksum() .

    printInt(iters); print('\t trees of depth '); printInt(depth); print('\t check: '); printInt(totalSum); print('\n') .

  0 .
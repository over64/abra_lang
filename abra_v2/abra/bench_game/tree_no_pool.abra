llvm
  @.printfInt = private constant [3 x i8] c"%d\00", align 1
  @.printfStr = private constant [3 x i8] c"%s\00", align 1
  declare i32 @printf(i8*,...)
  declare i32 @puts(i8*)
  .

type None = llvm void .
type Bool = llvm i8 .
type Int  = llvm i32 .
type Long = llvm i64 .
type String = ref llvm i8* .

def + = self: Int, other: Int -> llvm
  %1 = add nsw i32 %self, %other
  ret i32 %1 .Int

def - = self: Int, other: Int -> llvm
  %1 = sub nsw i32 %self, %other
  ret i32 %1 .Int

def > = self: Int, other: Int -> llvm
  %1 = icmp sgt i32 %self, %other
  %2 = zext i1 %1 to i8
  ret i8 %2 .Bool

def < = self: Int, other: Int -> llvm
  %1 = icmp slt i32 %self, %other
  %2 = zext i1 %1 to i8
  ret i8 %2 .Bool

def shl = self: Int, shift: Int -> llvm
  %1 = shl i32 %self, %shift
  ret i32 %1 .Int

def toLong = self: Int -> llvm
  %1 = zext i32 %self to i64
  ret i64 %1 .Long

def add = self: Long, other: Long -> llvm
  %1 = add nsw i64 %self, %other
  ret i64 %1 .Long

def >= = self: Long, other: Long -> llvm
  %1 = icmp sge i64 %self, %other
  %2 = zext i1 %1 to i8
  ret i8 %2 .Bool

def <= = self: Long, other: Long -> llvm
  %1 = icmp sle i64 %self, %other
  %2 = zext i1 %1 to i8
  ret i8 %2 .Bool

def print = s: String -> llvm
  %format = bitcast [3 x i8]* @.printfStr to i8*
  call i32 (i8*,...) @printf(i8* %format, i8* %s)
  ret void .None

def printInt = i: Int -> llvm
    %format = bitcast [3 x i8]* @.printfInt to i8*
    call i32 (i8*,...) @printf(i8* %format, i32 %i)
    ret void .None

type Range = (from: Int, to: Int, step: Int)

def each = self: Range, fn: \Int -> None ->
  i = self.from
  while i < self.to do
    fn(i)
    i = i + self.step ..

type Node = (left: Node | None, right: Node | None)

def asNode = self: Node | None, callback: \Node -> None -> llvm
  %1 = getelementptr { void (%"Node"*, i8*)*, i8* }, { void (%"Node"*, i8*)*, i8* }* %callback, i64 0, i32 0
  %fn = load void (%"Node"*, i8*)*, void (%"Node"*, i8*)** %1
  %2 = bitcast { void (%"Node"*, i8*)*, i8* }* %callback to i8*
  %3 = load %Node*, %Node** %self
  call void %fn(%Node* %3, i8* %2)
  ret void .None

def mkTree = depth: Int ->
  if depth > 0 do
    Node(mkTree(depth - 1), mkTree(depth - 1))
  else
    Node(none, none) ..Node

def checksum = self: Node ->
  sum = 1

  when self.left  is l: Node do
     self.right asNode lambda r: Node ->
       sum = sum + l.checksum() + r.checksum() .

  sum .Int

def main =
  minDepth = 4
  maxDepth = 21 # sys.arg(0).toInt()

  if maxDepth < minDepth + 2 do
    maxDepth = minDepth + 2 .

  tree = mkTree(maxDepth + 1)
  print('stretch tree of depth '); printInt(maxDepth + 1); print('\t check: '); printInt(tree.checksum()); print('\n')

  llTree = mkTree(maxDepth)
  print('long lived tree of depth '); printInt(maxDepth); print('\t check: '); printInt(llTree.checksum()); print('\n')

  Range(minDepth, maxDepth, 2) each lambda depth: Int ->
    iters    = 1 shl (maxDepth + minDepth - depth)
    totalSum = 0

    Range(1, iters + 1, 1) each lambda i: Int ->
      totalSum = totalSum + mkTree(depth).checksum() .

    printInt(iters); print('\t trees of depth '); printInt(depth); print('\t check: '); printInt(totalSum); print('\n') .

  0 .
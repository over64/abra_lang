type Task[E] = (name: String, action: (Ctx) -> None | E)
type ShellErr[E] = NoSuchTaskErr | E

type _ShellErr[Anon1E] = (tag1, (NoSuchTaskErr | (tag2, (IOErr | ShErr | KadabraErr))))

def eval[E] = { tasks: Seq[Task[E]] ->
    val taskName = os.args(1)
    val ctx = Ctx()

    match tasks.find(\t -> t.name == taskName)
        of task: Task[E] -> task.action(ctx)?
        of None -> return NoSuchTask(taskName)

}: None | ShellErr[E]

import abra.sh
import abra.io
import abra.kadabra
import abra.shell

def main =
    match
        shell.eval(seq.of(
            Task('run', { ctx ->
                val line = io.readLine?
                if line == 'xxx' then sh.mkDir('dir')?

            }),
            Task('compile', { ctx ->
                kadabra.compile('src/main.abra')?
            })
        ))
        of None -> 'ok'.print
        of err: NoSuchTaskErr -> 'task not found ${err.name}'.printErr
        of other -> 'task failed\n ${other.trace}'

# after type inference
type Anon1E = IOErr | ShErr | KadabraErr

def main: () -> ShellErr[Anon1E] =
    match
        shell.eval[Anon1E](seq.of[Anon1E](
            Task[Anon1E]('run', { ctx ->
                val line = io.readLine?
                if line == 'xxx' then sh.mkDir('dir')?

            }), # Task[IOErr | ShErr]
            Task[Anon1E]('compile', { ctx ->
                kadabra.compile('src/main.abra')?
            }) # Task[KadabraErr]
        ))
        of None -> 'ok'.print
        of err: NoSuchTaskErr -> 'task not found ${err.name}'.printErr
        of other: IOErr | ShErr | KadabraErr -> 'task failed\n ${other.trace}'

abra.io.EBADF('bad fd')
    abra.io:readLine.201
    abra.shell:eval.9
    app:main.23

type SomeErr[E] = IOErr | E
type E2 = IOErr | ShErr
SomeErr[IOErr] = IOErr | IOErr # compilation error!

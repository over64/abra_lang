def foo = x: Int, y: Int do
  io.println(x)
  io.println(y)
  x + y

def bar = x: Int,
          y: Int,
          fn: (Int, Int) -> Float do
  fn(x, y)

@meta.inline()
@meta.lowName('veryLongFunctionNameSoHardToSpellL')
def veryLongFunctionNameSoHardToSpell
    = x: Int, y: Int,
      fn: (Int, Int) -> Float do
  fn(x, y)

def main =
  @meta.immut()
  z = if io.args(0) == 'greet' then
        io.println('Hello!') 1
      else bar(1, 2, lambda x, y -> x / y)

  @meta.noLoopUnroll()
  (1 to 10)
    .map(lambda x -> x + 1)
    .filter(lambda x -> x mod 2 == 0)
    .take(5)
    .forEach with 1, 2, lambda x ->
      io.println(x)
      io.println(x + 1)
      foo(x)


type Vec3 = (x: Float, y: Float, z: Float)
type Vec3 = (x: Float,
             y: Float,
             z: Float)

type VeryLongTypeNameSoHardToSpell
     = (x: Float,
        y: Float,
        z: Float)

# is it so cool ???
type Vec3 = x: Float, y: Float, z: Float
type Vec3 = x: Float
          , y: Float
          , z: Float

type VeryLongTypeNameSoHardToSpell
     = x: Float
     , y: Float
     , z: Float

type StringOption = String | None
type StringOption = String |
                    None

type Some = Bar
          | None
          | Baz
          | Float

type VeryLongUnionTypeNameSoHardToSpell
     = Bar
     | None
     | Baz
     | Float


type Int = llvm { i32 }

def bar = f: Vec2, g: Int do
  x = if x > 0 do x + 1 else 0
  y = seq.of(1, 2, 3)
    .map with lambda x ->
      i = io.readInt()
	  x + i
    .forEach with 1, 2, lambda x ->
      println(x)
	  println(x)

def main = ->
  seq.of(1, 2, 3, 4, 5)
    .map(lambda x -> x + 1)
    .forEach with lambda x ->
      logger.info(lambda fd -> io.fmt(fd, 'x is %', x))
      io.println(x + 1), 3, 4, 5,
      io.readLine()

  y = if x mod 2 == 0 do 0
      else 1

def main =
  fn = lambda x: Int, y: Int ->
    z = io.readInt()
    io.println(x + y + z)

  seq.of(1, 2, 3, 4, 5)
    .map(x -> x + 1)
    .forEach with lambda x ->
      logger.info(lambda fd -> io.fmt(fd, 'x is %', x))
      io.println(x + 1)

  y = if x mod 2 == 0 do 0 else 3


# Kotlin
class FollowCameraSystem(
    private val cam: Camera
) : IteratingSystem(
    Family.all(CameraComponent::class.java, TransformComponent::class.java).get()
) {
    override fun processEntity(entity: Entity?, deltaTime: Float) {
        val targetC = Mappers.transform[entity] ?: return
        val camC = Mappers.camera[entity] ?: return

        if (targetC.pos.x - camC.leftBottomCorner.x > cam.viewportWidth / 2) {
            if (camC.rightUpperCorner.x - targetC.pos.x > cam.viewportWidth / 2) {
                cam.position.x = targetC.pos.x
            } else {
                cam.position.x = camC.rightUpperCorner.x - cam.viewportWidth / 2
            }
        } else {
            cam.position.x = camC.leftBottomCorner.x + cam.viewportWidth / 2
        }

        if (targetC.pos.y - camC.leftBottomCorner.y > cam.viewportHeight / 2) {
            if (camC.rightUpperCorner.y - targetC.pos.y > cam.viewportHeight / 2) {
                cam.position.y = targetC.pos.y
            } else {
                cam.position.y = camC.rightUpperCorner.y - cam.viewportHeight / 2
            }
        } else {
            cam.position.y = camC.leftBottomCorner.y + cam.viewportHeight / 2
        }
    }
}

# Abra
def process = entity: Entity | None, delta: Float do
  target = mappers.transform(entity)
  cam = mappers.camera(entity)

  posX = if target.pos.x - cam.leftBottom.x > cam.vpWidth / 2 do
           if cam.rightUpper.x - target.pos.x > cam.vpWidth / 2 do
             target.pos.x
           else cam.rightUpper.x - cam.vpWidth / 2
         else
           cam.leftBottom.x + cam.vpWidth / 2

  posY = if target.pos.y - cam.leftBottom.y > cam.vpHeight / 2 do
           if cam.rightUpper.y - target.pos.y > cam.vpHeight / 2 do
             target.pos.y
           else cam.rightUpper.y - cam.vpHeight / 2
         else
           cam.leftBottom.y + cam.vpHeight / 2

  cam.position = (posX, posY)

def main = args: Seq[String] do
  5 times lambda i ->
    i.println()

  bar.some with 1, some(),
    lambda i -> i + 1,
    lambda j ->
      j.println()
      j * j + 2 * math.pi()

  z = if x > 0 do x + 1 else 5

  z = if veryLongCOnditions() > 0
      do sideEffect() x + 1
      else someLongExpression()

  # Abra v2
  z = if x > 0 do sideEffect() x + 1
  else 5 .

  #Python
  if x > 0:
    z = x + 1
  else:
    z = 5

  # Kotlin
  z = if(x > 0) {
    sideEffect(); x + 1
  } else 5

  someFile = when io.fopen('tmp/file') is f: File do f
             else io.fmt('could not open file %', fname) sys.exit(1)

  f = when x
      is s: String do s.trim()
      is l: Long   do l + 1
      is m: Float  do f.sqrt()
      else 0

  if typeof(x) == String:
    f = s.trim()
  elif  l: Long:
      f = l + 1
    is m: Float:
      f = f.sqrt()
    else
      f = 0

  superLongVariableName =
    when x
    is s: String do
      s.trim()
    is l: Long do l + 1
    is m: Float do f.sqrt()
    else 0
import abra/arrays
import abra/trans
import abra/malloc
import abra/rc
import abra/arena
import abra/static
import abra/embed

def main = \x ->
    val a = arrays.for(1, 2, 3, 4,  .

type Node[T] = (v: T, next: Node[T])
type Int = llvm i32 .

# 1. Value типы всегда embedded в parent объект (объект, либо стек функции)
# 2. Если  тип включает поле reference типа, то он становится reference (защита от некорректного копирования)
# 3. Иерархии reference типов по умолчанию выделяются через ref counter. При необходимости выделяются через кастомный аллокатор через @allocator
# 4. Метки аллокаторов имеют ТОЛЬКО ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ. Аллокаторы для return и аргументов функции задаются вызывающей функцией
# 5. При присваивании нового инстанса используется аллокатор иерархии
# 6. Аллокаторы умны! Они получают DFG и решают можно ли так работать
# Noob: 1, 2
# Advanced: Noob + 3, 4, 5 + 6

def append[T] = \self: Node[T], v: T -> # self @ $1, v @ $2
    self.next = Node(v, Nil)
    # anon1 @ stack
    # anon1 <- v && v.isArg => v @ $2
    # self <- anon1 => anon1 @ $1, v @ $1
    if x < 2 do 1 else 2 .


def main = \ ->
    val x = 'hello' # x @stack
    io.println(x) .

def mk = \ ->
    val root = Node(1, Nil) # root @ stack
    var head = root # root <~ head

    var i = 0
    while i < 10 do # like a function call!
        head.next = Node(i, Nil) # root <- anon1 => anon1 @ root
        head = head.next # self replace => root <~ head
        i = i + 1 .

    head = root # head <~ root
    i = 0
    while i < 5 && head != Nil do head = head.next . # head <~ root

    head.next = Nil .

# 1. ref и value типы: семантика
# 2. Типы аллокаторов
# 2. графы объектов

type Node[T] = (x: T, next: Node[T] | Nil)
def main = \ ->
    val x = Node(1, Nil) # x @ $stack
    val y = Node(2, Nil) # y @ $stack
    x.next = y # x <- y => y @ x => y @ $stack
    x.next =

    io.println(x) .

def icon = \ -> embed.localFile('static/resources/main.ico') # Array[Byte]@static
def append[T] = \self: Node[T], v: T ->
    var head = self
    while head.next != Nil do head = head.next .
    head.next = self.alloc(Node(v, Nil)) .

def bar = \ ->
    val s = 'hello, world!' # s@rc
    val s2 = malloc.alloc('hello, world!') # s2@malloc
    val s3 = static.alloc('hello string from binary', section = 'global')

    val arena1 = arena.unlimited()

    val root = arena1.alloc(Node(v = 0, next = Nil)) # root@arena
    var head = root

    (1 to 100).forEach(\i ->
        val x = arena1.alloc[Node](i, Nil)
        head.next = x
        head = x)

    head = root
    while head != Nil do
        io.println(head.v)
        head = head.next .

    arena1.free() .

type Map[K, V] = (array: Array[V])

def put[K, V] = \self: Map[K, V], key: K, v: V, hash: (k: K) -> Int = key.hash ->
  array[hash(k)] = v .

def bar =
    val array: Array[Node[Int]] = malloc.alloc(8) 
    val map = Map[String, Node[Int]](array) # map <- array
    val node: Node[Int] = malloc.alloc(1, Nil)
    val node2: Node[Int] = malloc.alloc(2, Nil)
    map.put('hello', node) # map.array[i] <- node
    map.put('hello', node2) # map.array[i] <- node2 .

def fact = \n: Int ->
    n * fact(n - 1) .Int

val lambda = \i: Int -> # uber duper function
    val z = io.stdin.readInt
    i + z .

1 + 1
val r = xxx # comment
    .x
    .y()
    .z()

val lambda = \i ->
    val z = io.stdin.readInt
    i + z .

def + = \self: Int, other: Int -> llvm
    %1 = add nsw i32 %self, %other
    ret i32 %1.1.1
.Int

def xxx = \ x ->
    bar(
        io.readline
        io,
        asio.readline
        asio
    ) .
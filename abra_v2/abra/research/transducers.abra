type Node = (left: Node | None, right: Node | None)
type Stat = (iters: Int, depth: Int, sum: Int)

f mkTree = depth: Int ->
  if depth > 0 do
    Node(mkTree(depth - 1), mkTree(depth - 1))
  else
    Node(None, None) ..

f checksum = self: Node ->
  sum = 1

  when self.left is l: Node do
     sum = sum + l.checksum() .
  when self.right is r: Node do
     sum = sum + r.checksum() .

  sum .

f main =
  minDepth = 4
  maxDepth = sys.arg(0).toInt()

  if maxDepth < minDepth + 2 do
    maxDepth = minDepth + 2 .

  pool.use with f
    tree = mkTree(maxDepth + 1)
    fmt.print(
      io.stdout,
      'stretch tree of depth %v %t check: %v%n',
      maxDepth + 1,
      tree.checksum()) .

  longLiveTree: Pool[Node] =
    pool.alloc with f
      mkTree(maxDepth) .

  outBuf = seq.uninitialized[Stat](maxDepth + 1)

  thread.par with 4, f tp ->
    range.of(minDepth, maxDepth, 2).forEach with f depth ->
      tp.spawn[Int, None] with f depth ->
        iters    = 1 shl (maxDepth + minDepth - depth)
        totalSum = 0

        (1 to iters + 1).forEach with f i ->
          pool.use with f
            totalSum = totalSum + mkTree(depth).checksum() ..

        outBuff(depth) = Stat(iters, depth, totalSum) ...

  outBuff.forEach with f stat ->
    fmt.print(io.stdout, '%v%t trees of depth %v%t check: %v%n',
      stat.iters, stat.depth, stat.sum) .

  longLiveTree.view with f tree ->
    fmt.print('long lived tree of depth %v%t check: %v%n',
      maxDepth, tree.checkSum())
  longLiveTree.free() .

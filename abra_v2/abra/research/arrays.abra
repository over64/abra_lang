val x = Seq3[Int](1, 2, 3)            # Seq3[Int]
val y = seq.make(15, \i -> i + 1)     # Seq15[Int]
val y = seq.make(n, \i -> i + 1)      # Seq[Int]
val z = Seq2(Seq(1, 2, 3), Seq(1, 2)) # Seq2[Seq[Int]]

Seq:
    => статические
        => SeqN[T]
        => ~ C Array
    => динамические
        => Seq[T]
        => выделяются на куче через malloc

type String = llvm { i8* }

Строки
 => статические в бинаре
 => динамические на куче
1. Строки immutable
 => Можно копировать как указатель
   => Нужно учитывать время жизни
   => строки из C FFI

Решение 1:
    => все инстансы строк динамические на куче
    => встраиваются как указатель
        => копировать как указатель в случае move
        => копировать как указатель в случае loan
        => в остальных случаях создание новой сторки через malloc
        => transitive loan + move ?
    => строки immutable
        => можно копировать как указатель без проверки мутабельности
    => строки из C FFI выделяются через malloc

Move pattern для строк:
    => Можем разделять много указателей на строку
    => Контролируем только lifetime
        => расшариваем все, кроме return value
    val x = 'Hello'
    val y = x
    val z = Bar(x, y)

Первая реализация: полное копирование, что для Seq, что для String
Вторая реализация: инфраструктура для loan / move анализа
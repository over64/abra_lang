type Ast = Value of (x: Int)
	     | Add of (l: Ast, r: Ast)
		 | Sub of (l: Ast, r: Ast)
		 | Mul of (l: Ast, r: Ast)
		 | Div of (l: Ast, r: Ast)

def eval = { ast: Ast ->
    match ast
        of Value(x) -> x
        of Add(l, r) -> eval(l) + eval(r)
        of Sub(l, r) -> eval(l) - eval(r)
        of Mul(l, r) -> eval(l) * eval(r)
        of Div(l, r) -> eval(l) / eval(r)
}: Int

def main = {
    val ast = Add(
        Add(Value(1), Value(2)),
        Sub(Value(2), Value(1))
    )

    eval(ast)
}: Int

# abra.io
type IOString = String
              | IOError of (msg: String)

def readLine: () -> IOString = llvm {
 ; bla bla bla
}

# some other module
import abra.io with IOString

def readTwoLines = {
    val line1 = io.readLine() unless e@IOError(msg) -> SomeError(msg)
    val line2 = io.readLine() unless IOError

    line1 + line2
}: IOString

def readTwoLines = {
    val line1 = match io.readLine()
        of s: String -> s
        of e: IOError -> return e

    val line2 = match io.readLine()
        of s: String -> s
        of e: IOError -> return e
    # line 1 and line 2 is String
    line1 + line2
}: IOString

def readTwoLinesOrFail = {
    val line1 = io.readLine() falling IOError
    val line2 = io.readLine() falling IOError

    line1 + line2
}: String

def readTwoLinesOrFail = {
    val line1 = match io.readLine()
        of s: String -> s
        of e: IOError -> fall(e)

    val line2 = match io.readLine()
        of s: String -> s
        of e: IOError -> fall(e)

    line1 + line2
}: String

#conditional statement
def main = {
    val line = io.readLine
    match line {
        of str: String
            str.print
            str.print
    }
}

try {
    foo()
    bar()
} catch(ex: IOException) {
    // some
}
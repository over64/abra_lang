type Int = llvm.types { i32 }
type Byte = llvm.types { u8 }
type A = { val f1: Int, val f2: Byte }
type String as Byte[]

type Array1 as Int[]
type Array2 as Array1[2]
type Array3 as Array2[] // = Int[][2][]

val a: Int[][2][] = [
    [[1], [1,2,3]],
    [[], []],
    [[], [4]]
]

val a: Int[][2][] = arrayInit({ i: UInt, j: UInt, k: UInt =>

})

val a: Int[] = [1, 2, 3, 4]
val a1: Int[] = [1, 2, 3, 4]
val b: Int[][] = [a0, a1]

typeclass Bytes = Byte[4] as B4 | Byte[2] as B2
typeclass Terms = Unit as Autumn | Unit as Spring

// Serialize.abra
typeclass Serializable = Int | Bool
typeclass Bin = Byte@4 | Byte

export def serialize(s: Serializable): Bin = s match {
	case i: Int => Byte@4(i.toByte, i.shl(8).toByte, i.shl(16).toByte, i.shl(24).toByte)
	case b: Bool => if(b) 1 else 0
}

// FileStore.abra
import File.write
typeclass Storable = Byte@4 | Byte
export def store(file: File, s: Storable) = file.write(s)

// SerializeAndStore.abra
require type T, U with {
    def serialize(self: T): U
    def store(u: U): Unit
}

export def serializeAndStore(t: T) = store(t.serialize)

// Main.abra
import Serialize.serialize
import File.withFile
import FileStore as fstore

import SerializeAndStore(Serializable, Storable).serializeAndStore // error ->
// error: could not find function store(u: Byte@4): Unit
// error: could not find function store(u: Byte): Unit

def main(): Int = {
    val a: Int = 42
    val b: Bool = false

    withFile('/tmp/out.bin', { file =>
        import SerializeAndStore(Serializable, Storable).* where {
	    store = { s: Storable => fstore.store(file, s) }
	}

	serializeAndStore(a)
	serializeAndStore(b)
    })
}



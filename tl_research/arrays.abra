macro Array$n[T] = {
    +:   (self: Self, other: Array$m[T]) -> Array${n + m}[T]
    get: (self: Self, index: Int) -> T
    set: (self: Self, index: Int, value: T) -> Unit
}

val a1: Int x 3 = (1, 2, 3)
val a2 = (1, 2) # Int x 2

val a3 = a1 concat a2 # Int x 5
val some = (1.0, 1) # (Float, Int)

data Vec3f = (x: Float, y: Float, z: Float)
data Node  = (v: Int, next: Node | Unit)
data IntOption      = Int | Unit
data Vec3fv2        = Float x 3


macro def concat: (self: T x $n, other: T x $m) -> T x ${m + n}
macro def length: (self: T x ?) -> Int

def foo = { arr: Int x ? ->

}

macro data Array$n[T] = T x $n
macro data Mat${m}x${n}[T] = Array${n}[T] x ${m}

data StaticMap[]
# data Mat$m$n[T] = llvm { [T x $m * $n] }


val a1: Mat2x2[Int] = ((0, 1), (1, 0))
val a1 = ((0, 1), (1, 0)) # Int x 2 x 2

trait Comparable[T] = {
    compareTo: (self, other: T) -> Int
}

macro Seq[T] = {
    +:   (self: Self, other: Seq[T]) -> Seq[T]
    map: (self: Self, fn: (x: T) -> U) -> Seq[U]
    get: (self: Self, index: Int) -> T
    set: (self: Self, index: Int, value: T) -> Unit
}

type operations: (T1, T2, ... Tn ) - algebraic mul T1 * T2 * ... Tn
                 T1 | T2 |... Tn   - algebraic sum T1 + T2 + ... Tn
                 T1 x n1 x n2      - vectorize [[T1 x n1] x n2]

data Vec3f     = (Float, y: Float, z: Float)
data StringOpt = String | Unit
data Array3    = Int x 3 x 3

filter: ArrayN -> Array
        Array  -> Array

trait Map[K, V]
